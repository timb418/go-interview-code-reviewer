Вот список тем, которые я тренирую:

**План тем для подготовки Middle Go Backend Developer**

**I. Основы языка и структуры данных (с подвохом)**

1.  **Переменные, Типы, Указатели:**
    *   **Задачи:** Нулевые значения типов. Неявное/явное приведение типов. Работа с указателями, разыменование. Передача по значению vs по указателю. Влияние на производительность и изменяемость.
    *   **Проверяем:** Понимание копирования значений, области видимости, времени жизни переменных, основ работы с памятью.
2.  **Структуры (Structs):**
    *   **Задачи:** Встраивание (embedding) vs композиция. Копирование структур. Сравнение структур. Теги полей (для `json`, `db` и т.д.). Методы с value/pointer receiver.
    *   **Проверяем:** Понимание организации данных, выбор между value/pointer receiver, взаимодействие со стандартной библиотекой через теги.
3.  **Слайсы (Slices):**
    *   **Задачи:** "Что выведет" при `append` (с переаллокацией и без). Создание подслайсов и их влияние друг на друга. Передача слайса в функцию. `nil` vs пустой слайс. Ошибки с `len` и `cap`. Потенциальные утечки памяти.
    *   **Проверяем:** Глубокое понимание `len`, `cap`, указателя на базовый массив. Механизм `append`. Копирование заголовка слайса.
4.  **Карты (Maps):**
    *   **Задачи:** Порядок итерации. Чтение/запись в `nil` map. Проверка наличия ключа. Конкурентный доступ (race condition). Копирование map.
    *   **Проверяем:** Понимание неупорядоченности, необходимости проверки ключа, разницы между `nil` и пустой map, опасности конкурентного доступа.
5.  **Строки (Strings) и Руны (Runes):**
    *   **Задачи:** Итерация по строке (`range` vs индекс). `len()` строки с multi-byte символами. Конвертация `string <-> []byte <-> []rune`. Иммутабельность строк и её следствия.
    *   **Проверяем:** Понимание UTF-8, разницы между байтами и рунами, эффективности операций со строками.
6.  **Управляющие конструкции:**
    *   **Задачи:** Особенности `range` с массивами/слайсами/map'ами (копирование значений). `fallthrough` в `switch`. Использование `break`/`continue` с метками.
    *   **Проверяем:** Нюансы итераторов, контроль потока выполнения.

**II. Функции, Методы, Интерфейсы**

7.  **Функции:**
    *   **Задачи:** Именованные возвращаемые значения и их влияние на `defer`. Вариативные функции. Замыкания (closures) и захват переменных (особенно в циклах и горутинах).
    *   **Проверяем:** Понимание области видимости, времени жизни переменных в замыканиях, механизма возврата значений.
8.  **Методы:**
    *   **Задачи:** Выбор между value и pointer receiver (когда и почему). Неявное взятие адреса/разыменование при вызове методов.
    *   **Проверяем:** Понимание влияния ресивера на модификацию объекта и производительность.
9.  **Интерфейсы:**
    *   **Задачи:** Неявная реализация. Пустой интерфейс (`interface{}`) - использование и опасности. Type assertion vs Type switch. Проверка `ok`. `nil` интерфейс vs интерфейс с `nil` значением внутри. Встраивание интерфейсов.
    *   **Проверяем:** Полиморфизм в Go, работа с динамическими типами, обработка ошибок приведения типов, "нулевые" значения интерфейсов.

**III. Управление выполнением и Ошибки**

10. **`defer`:**
    *   **Задачи:** Порядок выполнения (LIFO). Момент вычисления аргументов. Захват переменных в замыканиях `defer`. Использование для освобождения ресурсов (`Close()`, `Unlock()`).
    *   **Проверяем:** Понимание отложенного выполнения, стека `defer`, взаимодействия с переменными.
11. **`panic` / `recover`:**
    *   **Задачи:** Когда использовать `panic`. Как работает `recover` (только в `defer`). Распространение паники между горутинами. Сравнение с `error`.
    *   **Проверяем:** Понимание механизма паники, стратегии восстановления, идиоматическое использование.
12. **Обработка ошибок:**
    *   **Задачи:** Создание ошибок (`errors.New`, `fmt.Errorf`). Оборачивание ошибок (wrapping, Go 1.13+). Проверка типа ошибки (`errors.As`). Проверка на конкретную ошибку (`errors.Is`). Идиоматика обработки (`if err != nil`).
    *   **Проверяем:** Стратегии обработки ошибок, сохранение контекста, создание кастомных типов ошибок.

**IV. Конкурентность (Concurrency)**

13. **Горутины (Goroutines):**
    *   **Задачи:** Запуск горутин. Классическая ошибка с захватом переменной цикла. Ожидание завершения (`sync.WaitGroup`). Потенциальные утечки горутин.
    *   **Проверяем:** Понимание легковесности горутин, асинхронного выполнения, жизненного цикла, синхронизации завершения.
14. **Каналы (Channels):**
    *   **Задачи:** Буферизованные vs небуферизованные. Блокировки при чтении/записи. Закрытие каналов (`close`). Чтение из закрытого канала (`val, ok := <-ch`). Итерация по каналу (`range`). Паника при записи в закрытый канал.
    *   **Проверяем:** Понимание механизмов синхронизации и передачи данных через каналы, состояний канала.
15. **`select`:**
    *   **Задачи:** Работа с несколькими каналами. Неблокирующие операции (`default` case). Таймауты (`time.After`). Приоритезация (случайный выбор при нескольких готовых).
    *   **Проверяем:** Мультиплексирование каналов, реализация неблокирующих операций и таймаутов.
16. **Примитивы синхронизации (`sync`):**
    *   **Задачи:** `Mutex` vs `RWMutex` (выбор, deadlock). `sync.Once` (инициализация синглтонов). `sync.Pool` (переиспользование объектов, нюансы). `sync.Cond` (условные переменные). Атомарные операции (`sync/atomic`).
    *   **Проверяем:** Выбор подходящего примитива, избегание deadlock'ов, понимание работы примитивов.
17. **Race Conditions:**
    *   **Задачи:** Найти race condition в коде. Исправить race condition (используя мьютексы, каналы, atomic). Использование race detector (`go run -race`).
    *   **Проверяем:** Понимание сути состояния гонки, умение его обнаруживать и устранять.
18. **Пакет `context`:**
    *   **Задачи:** Передача контекста. Отмена операций (`context.WithCancel`). Дедлайны и таймауты (`WithDeadline`, `WithTimeout`). Проверка отмены (`ctx.Done()`). Передача значений (`WithValue`, с осторожностью).
    *   **Проверяем:** Управление жизненным циклом запросов/операций, graceful shutdown, передача request-scoped данных.
19. **Паттерны конкурентности:**
    *   **Задачи:** Реализовать/проанализировать простые паттерны: Worker Pool, Fan-in/Fan-out, Rate Limiter, Circuit Breaker.
    *   **Проверяем:** Умение применять стандартные решения для типовых задач конкурентного программирования.

**V. Стандартная библиотека и Экосистема**

20. **`encoding/json`:**
    *   **Задачи:** Маршалинг/анмаршалинг. Теги полей (`omitempty`, `-`, имя). Работа с `map[string]interface{}` и `json.RawMessage`. Кастомные (Un)Marshaller'ы. Обработка `null`.
    *   **Проверяем:** Работа с JSON, кастомизация сериализации/десериализации.
21. **`net/http`:**
    *   **Задачи:** Создание HTTP сервера (`http.ListenAndServe`, `http.Handler/HandlerFunc`). Чтение запроса (заголовки, тело, параметры). Отправка ответа. Middleware (реализация, порядок). HTTP клиент (`http.Client`, `Get`, `Post`).
    *   **Проверяем:** Основы веб-разработки на Go, обработка HTTP запросов/ответов.
22. **`database/sql`:**
    *   **Задачи:** `sql.DB` (пул). `Query` vs `QueryRow` vs `Exec`. Обработка `sql.Rows` (`Scan`, `Close`, `Err`). Работа с `NULL`. Подготовленные выражения (`Prepare`). Транзакции.
    *   **Проверяем:** Взаимодействие с реляционными БД, правильная работа с ресурсами.
23. **Тестирование (`testing`):**
    *   **Задачи:** Написание unit-тестов. Табличные тесты. Бенчмарки. Использование `t.Run`. Основы мокинга (через интерфейсы). Тестирование конкурентного кода.
    *   **Проверяем:** Навыки написания тестов, покрытие кода, измерение производительности.
24. **Работа с файлами и IO (`os`, `io`):**
    *   **Задачи:** Чтение/запись файлов. Интерфейсы `io.Reader`, `io.Writer`, `io.Closer`. `io.Copy`. Работа с буферами (`bytes.Buffer`, `strings.Builder`).
    *   **Проверяем:** Основы работы с вводом/выводом.

**VI. Продвинутые темы и Инструменты**

25. **Reflection (`reflect`):**
    *   **Задачи:** Когда использовать reflection (например, в фреймворках, ORM). Получение типа/значения. Изменение значений. Производительность и риски.
    *   **Проверяем:** Понимание возможностей и ограничений reflection.
26. **Сборка мусора (GC):**
    *   **Задачи:** Найти код, создающий много аллокаций. Предложить оптимизацию для снижения нагрузки на GC. Базовое понимание работы GC в Go.
    *   **Проверяем:** Понимание влияния аллокаций на производительность.
27. **Профилирование (`pprof`):**
    *   **Задачи:** Интерпретация простого CPU/memory профиля. Подключение `net/http/pprof`. Генерация профилей.
    *   **Проверяем:** Базовые навыки поиска узких мест в производительности.
28. **Go Modules:**
    *   **Задачи:** Работа с зависимостями (`go.mod`, `go.sum`). Команды `go get`, `go mod tidy`. Версионирование.
    *   **Проверяем:** Управление зависимостями проекта.
29. **Generics (Go 1.18+):**
    *   **Задачи:** Написать/проанализировать простую дженерик-функцию/тип. Type constraints. Использование стандартных дженерик-пакетов (`slices`, `maps`).
    *   **Проверяем:** Понимание синтаксиса и концепции дженериков.


Твоя задача - сделать необходимое количество задач для прорабатывания темы. Максимальное количество - 15 на тему.
Нынешняя тема - PASTE HERE. Сначала выпиши конкретные темы задач, что они проверяют, составь план задач, 
который необходим, чтобы проработать тему. 
Вид задачи должен быть похож на интервью. 
В рамках подготовки к собеседованиям на бэкенд-разработчика Go, хотел бы попрактиковаться в решении задач, 
которые часто встречаются на технических интервью. Интересуют задания формата "анализ кода" 
(вывод, ошибки, рефакторинг). Просьба предоставить короткие и показательные фрагменты кода на Go, 
акцентирующие внимание на ключевых аспектах языка и типичных проблемах.

Формат описания задач:
```go
// go code
```


<details>
  <summary>Spoiler (click to reveal)</summary>

  Task explanation
</details>

Это markdown, он будет храниться в github.

Не включай комментарии-подсказки вроде "*p = 10 // Эта строка вызовет панику". 
Если комментарии нужны для удобства чтения, пускай будут, но на интервью подсказок не будет.