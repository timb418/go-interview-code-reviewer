Хорошо, переформатирую задачи по вашему шаблону.

---

**Задача 1: Нулевые значения**

```go
package main

import "fmt"

type MyStruct struct {
	Value int
}

func main() {
	var i int
	var f float64
	var b bool
	var s string
	var p *int
	var sl []int
	var m map[string]int
	var st MyStruct
	var fn func()
	var iface interface{}

	fmt.Printf("int: %d\n", i)
	fmt.Printf("float: %f\n", f)
	fmt.Printf("bool: %t\n", b)
	fmt.Printf("string: [%s]\n", s) // Добавил скобки для наглядности пустой строки
	fmt.Printf("pointer: %v\n", p)
	fmt.Printf("slice: %v (is nil: %t)\n", sl, sl == nil)
	fmt.Printf("map: %v (is nil: %t)\n", m, m == nil)
	fmt.Printf("struct: %+v\n", st) // Используем %+v для показа полей
    fmt.Printf("function: %v (is nil: %t)\n", fn, fn == nil)
	fmt.Printf("interface: %v (is nil: %t)\n", iface, iface == nil)
}
```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** Что выведет следующий код? Объясните значение каждой выведенной переменной.

  **Что проверяем:** Знание нулевых значений для различных категорий типов в Go.

  **Объяснение:**
  *   `int`: 0
  *   `float64`: 0.0 (или 0.000000 в зависимости от формата)
  *   `bool`: false
  *   `string`: "" (пустая строка)
  *   `*int`: `<nil>` (нулевой указатель)
  *   `[]int`: `[]` (пустой срез), `is nil: true` (нулевой срез)
  *   `map[string]int`: `map[]` (пустая карта), `is nil: true` (нулевая карта)
  *   `MyStruct`: `{Value:0}` (структура с нулевыми значениями для ее полей)
  *   `func()`: `<nil>` (нулевое значение для типа функции)
  *   `interface{}`: `<nil>` (нулевое значение для интерфейса)

  Этот пример показывает, что переменные в Go всегда инициализируются нулевыми значениями для своего типа, если им не присвоено другое значение явно.
</details>

---

**Задача 2: Разыменование `nil` указателя**

```go
package main

import "fmt"

func main() {
	var p *int
	fmt.Println("Before dereference")
	// Пытаемся изменить значение, на которое указывает p
	*p = 10 // Эта строка вызовет панику
	fmt.Println("After dereference") // Эта строка не выполнится
}
```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** Что произойдет при выполнении этого кода? Если будет ошибка, то какая и почему?

  **Что проверяем:** Понимание того, что разыменование `nil`-указателя приводит к панике времени выполнения (runtime panic).

  **Объяснение:**
  Код выведет "Before dereference", а затем выполнение программы прервется с паникой (runtime panic). Причина: переменная `p` является указателем типа `*int`, но она не инициализирована и содержит нулевое значение (`nil`). Попытка разыменовать `nil`-указатель (операция `*p = 10`) недопустима, так как он не указывает на действительную область памяти, куда можно было бы записать значение 10. Ошибка обычно выглядит как `panic: runtime error: invalid memory address or nil pointer dereference`.
</details>

---

**Задача 3: Приведение типов**

```go
package main

import "fmt"

func main() {
	var f float32 = 3.9
	var i int = int(f) // Явное приведение

	// var i2 int = f // Попытка неявного приведения (вызовет ошибку компиляции)

	fmt.Printf("Float: %f, Int: %d\n", f, i)

    type MyInt int
	var myI MyInt = MyInt(i) // Требуется явное приведение даже для одного и того же базового типа
	// var myI2 MyInt = i    // Ошибка компиляции: cannot use i (variable of type int) as MyInt value in variable declaration
	fmt.Println(myI)
}
```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** Что выведет этот код? Почему результат именно такой? Что будет, если раскомментировать строки с `i2` и `myI2`?

  **Что проверяем:** Понимание необходимости явного приведения между числовыми типами, возможную потерю точности (отбрасывание дробной части), и что Go требует явного приведения даже между типами с одинаковым базовым типом.

  **Объяснение:**
  *   Вывод будет: `Float: 3.900000, Int: 3` и затем `3`.
  *   При явном приведении `float32` к `int` (`int(f)`), дробная часть отбрасывается (не округляется). Поэтому `3.9` становится `3`.
  *   Если раскомментировать `var i2 int = f`, произойдет ошибка компиляции, так как Go не выполняет неявное приведение между `float32` и `int`.
  *   Тип `MyInt` является *отдельным* типом, хотя его базовый тип - `int`. Go требует явного приведения `MyInt(i)` для присваивания значения типа `int` переменной типа `MyInt`. Если раскомментировать `var myI2 MyInt = i`, также произойдет ошибка компиляции.
</details>

---

**Задача 4: Передача базового типа по значению**

```go
package main

import "fmt"

func modifyValue(val int) {
	fmt.Printf("Inside modifyValue (before): %d\n", val)
	val = val * 10
	fmt.Printf("Inside modifyValue (after): %d\n", val)
}

func main() {
	x := 5
	fmt.Printf("In main (before call): %d\n", x)
	modifyValue(x)
	fmt.Printf("In main (after call): %d\n", x)
}
```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** Что выведет этот код? Объясните почему.

  **Что проверяем:** Понимание того, что при передаче по значению функция работает с *копией* переменной, и оригинал не изменяется.

  **Объяснение:**
  Вывод будет:
  ```
  In main (before call): 5
  Inside modifyValue (before): 5
  Inside modifyValue (after): 50
  In main (after call): 5
  ```
  При вызове `modifyValue(x)`, значение переменной `x` (равное 5) копируется в параметр `val` функции. Внутри функции `modifyValue` изменяется только эта *копия* (`val` становится 50). Исходная переменная `x` в функции `main` остается неизменной (равной 5).
</details>

---

**Задача 5: Передача базового типа по указателю**

```go
package main

import "fmt"

func modifyPointer(ptr *int) {
	// Обратите внимание: вывод адресов может отличаться при каждом запуске
	fmt.Printf("Inside modifyPointer (before): value=%d, address_of_pointer=%p, points_to=%p\n", *ptr, &ptr, ptr)
	*ptr = *ptr * 10
	fmt.Printf("Inside modifyPointer (after): value=%d, address_of_pointer=%p, points_to=%p\n", *ptr, &ptr, ptr)
}

func main() {
	x := 5
	// Обратите внимание: вывод адресов может отличаться при каждом запуске
	fmt.Printf("In main (before call): value=%d, address=%p\n", x, &x)
	modifyPointer(&x) // Передаем адрес переменной x
	fmt.Printf("In main (after call): value=%d, address=%p\n", x, &x)
}
```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** Что выведет этот код? Объясните почему.

  **Что проверяем:** Понимание того, что при передаче указателя функция получает адрес оригинала и может изменить значение по этому адресу, влияя на исходную переменную.

  **Объяснение:**
  Вывод будет примерно таким (адреса будут другими):
  ```
  In main (before call): value=5, address=0xc000018030
  Inside modifyPointer (before): value=5, address_of_pointer=0xc00000e038, points_to=0xc000018030
  Inside modifyPointer (after): value=50, address_of_pointer=0xc00000e038, points_to=0xc000018030
  In main (after call): value=50, address=0xc000018030
  ```
  При вызове `modifyPointer(&x)` передается адрес переменной `x`. Параметр `ptr` внутри функции `modifyPointer` теперь хранит этот адрес (`points_to` будет равен адресу `x` в `main`). Операция `*ptr = *ptr * 10` разыменовывает указатель `ptr` (получает доступ к значению по адресу, который он хранит) и изменяет это значение. Так как `ptr` указывает на `x`, изменяется сама переменная `x` в функции `main`. Обратите внимание, что сам указатель `ptr` передается по значению (у него свой адрес `address_of_pointer`), но *значение*, которое он хранит (адрес `x`), позволяет изменить оригинал.
</details>

---

**Задача 6: Передача структуры по значению**

```go
package main

import "fmt"

type Config struct {
	ID   string
	Port int
}

func updateConfigValue(cfg Config) {
	// Адреса будут отличаться при каждом запуске
	fmt.Printf("Inside func (before): %+v, address: %p\n", cfg, &cfg)
	cfg.ID = "updated-id"
	cfg.Port = 9000
	fmt.Printf("Inside func (after): %+v, address: %p\n", cfg, &cfg)
}

func main() {
	myConfig := Config{ID: "initial-id", Port: 8080}
	// Адреса будут отличаться при каждом запуске
	fmt.Printf("In main (before call): %+v, address: %p\n", myConfig, &myConfig)
	updateConfigValue(myConfig)
	fmt.Printf("In main (after call): %+v, address: %p\n", myConfig, &myConfig)
}

```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** Что выведет этот код? Почему?

  **Что проверяем:** Понимание, что структуры (как и базовые типы) по умолчанию передаются по значению (копируются целиком), и модификация копии не влияет на оригинал.

  **Объяснение:**
  Вывод будет примерно таким (адреса будут разными):
  ```
  In main (before call): {ID:initial-id Port:8080}, address: 0xc00009e010
  Inside func (before): {ID:initial-id Port:8080}, address: 0xc00009e030
  Inside func (after): {ID:updated-id Port:9000}, address: 0xc00009e030
  In main (after call): {ID:initial-id Port:8080}, address: 0xc00009e010
  ```
  При вызове `updateConfigValue(myConfig)` вся структура `myConfig` копируется в параметр `cfg`. Обратите внимание, что адрес `&cfg` внутри функции отличается от адреса `&myConfig` в `main`. Функция `updateConfigValue` изменяет поля только этой *копии* структуры. Исходная структура `myConfig` остается неизменной.
</details>

---

**Задача 7: Передача структуры по указателю**

```go
package main

import "fmt"

type Config struct {
	ID   string
	Port int
}

func updateConfigPointer(cfg *Config) {
	// Адреса будут отличаться при каждом запуске
	fmt.Printf("Inside func (before): %+v, address_of_pointer: %p, points_to: %p\n", *cfg, &cfg, cfg)
	cfg.ID = "updated-id" // Go позволяет cfg.ID вместо (*cfg).ID
	cfg.Port = 9000
	fmt.Printf("Inside func (after): %+v, address_of_pointer: %p, points_to: %p\n", *cfg, &cfg, cfg)
}

func main() {
	myConfig := Config{ID: "initial-id", Port: 8080}
	// Адреса будут отличаться при каждом запуске
	fmt.Printf("In main (before call): %+v, address: %p\n", myConfig, &myConfig)
	updateConfigPointer(&myConfig) // Передаем адрес структуры
	fmt.Printf("In main (after call): %+v, address: %p\n", myConfig, &myConfig)
}
```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** Что выведет этот код? Почему? Сравните с предыдущей задачей.

  **Что проверяем:** Понимание, что передача указателя на структуру позволяет модифицировать исходную структуру. Также проверяется знание синтаксического сахара (`cfg.ID` вместо `(*cfg).ID`).

  **Объяснение:**
  Вывод будет примерно таким (адреса будут другими):
  ```
  In main (before call): {ID:initial-id Port:8080}, address: 0xc00009e010
  Inside func (before): {ID:initial-id Port:8080}, address_of_pointer: 0xc00000e038, points_to: 0xc00009e010
  Inside func (after): {ID:updated-id Port:9000}, address_of_pointer: 0xc00000e038, points_to: 0xc00009e010
  In main (after call): {ID:updated-id Port:9000}, address: 0xc00009e010
  ```
  При вызове `updateConfigPointer(&myConfig)` передается адрес структуры `myConfig`. Параметр `cfg` внутри функции хранит этот адрес (`points_to` указывает на тот же адрес, что и `&myConfig` в `main`). Модификации `cfg.ID` и `cfg.Port` изменяют поля исходной структуры `myConfig` по этому адресу. Поэтому после вызова функции структура `myConfig` в `main` оказывается измененной. Сравните с предыдущей задачей, где оригинал не менялся.
</details>

---

**Задача 8: Концептуальный вопрос**

```go
// Нет кода для этой задачи
```

<details>
  <summary>Spoiler (click to reveal)</summary>

  **Вопрос:** В каких случаях предпочтительнее передавать аргумент в функцию по значению, а в каких — по указателю? Назовите основные причины для каждого выбора (например, с точки зрения изменяемости данных и производительности). Приведите примеры типов данных, которые чаще передают одним способом, а которые — другим.

  **Что проверяем:** Понимание практических аспектов выбора между передачей по значению и по указателю.

  **Объяснение:**

  *   **Передача по значению (Value):**
      *   **Когда:**
          *   Нужно гарантировать, что функция не изменит исходные данные.
          *   Тип данных "маленький" (базовые типы: `int`, `float`, `bool`, `string`; небольшие структуры). Копирование дешево.
          *   Тип по своей природе неизменяем или копирование является ожидаемым поведением.
      *   **Плюсы:** Безопасность (нет случайных модификаций оригинала), проще рассуждать о коде (локальные изменения).
      *   **Минусы:** Расходы на копирование для больших структур. Невозможность изменить оригинал.
      *   **Примеры:** `int`, `bool`, `float`, `string` (хотя строка внутренне сложнее, ее семантика - передача по значению), маленькие структуры конфигурации или DTO, которые не должны меняться.

  *   **Передача по указателю (Pointer):**
      *   **Когда:**
          *   Нужно, чтобы функция *могла* изменить исходные данные. Это основной способ реализации методов, изменяющих состояние объекта.
          *   Структура данных "большая", и копирование дорого (экономия памяти и времени).
          *   Семантика типа подразумевает единственность или разделяемое состояние (например, дескрипторы файлов, сетевые соединения, объекты с мьютексами).
          *   Нужно обработать возможность отсутствия значения (`nil`).
      *   **Плюсы:** Эффективность для больших данных, возможность модификации оригинала.
      *   **Минусы:** Возможность случайной модификации оригинала (требует большей осторожности), необходимость проверки на `nil`. Может усложнить рассуждения о состоянии данных.
      *   **Примеры:** Большие структуры, объекты, которые нужно модифицировать (`*bytes.Buffer`), объекты, представляющие ресурсы (`*os.File`, `*sql.DB`, `*http.Request`), структуры с мьютексами (`*sync.Mutex` часто встраивают, но методы работают с указателем на содержащую структуру).

  **Важное замечание про срезы (slices) и карты (maps):** Сами срезы и карты передаются *по значению*, но копируется только их заголовок (дескриптор), который содержит указатель на базовый массив (для среза) или хеш-таблицу (для карты). Поэтому изменения *элементов* внутри среза или карты, сделанные в функции, будут видны снаружи. Однако, если функция изменяет сам заголовок (например, через `append` для среза, что может привести к переаллокации и изменению указателя, длины и емкости), эти изменения заголовка не будут видны снаружи, если не вернуть новый срез. Подробнее это рассматривается в темах про срезы и карты.
</details>

---

Готово! Задачи для темы I.1 переформатированы. Можем переходить к следующей теме (I.2 Структуры) или обсудить эти?