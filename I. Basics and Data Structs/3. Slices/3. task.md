### Задача 1

```go
package main

import "fmt"

func main() {
	s := []int{1, 2, 3}
	fmt.Println(s, len(s), cap(s))

	s = append(s, 4)
	fmt.Println(s, len(s), cap(s))

	s = append(s, 5, 6)
	fmt.Println(s, len(s), cap(s))
}
```

Task: Проанализируйте код и предскажите вывод программы. Объясните, как изменяются `len` и `cap` слайса `s` после каждой операции `append`.

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**


[1 2 3] 3 3
[1 2 3 4] 4 6
[1 2 3 4 5 6] 6 6

**Task Explanation:**

Первоначально слайс `s` инициализирован с тремя элементами и имеет длину 3 и ёмкость 3.

Первый `append` добавляет один элемент (4). Так как текущей ёмкости (3) недостаточно, Go выделяет новый базовый массив большей ёмкости (обычно удваивая или увеличивая в зависимости от реализации, в данном случае до 6). Данные из старого массива копируются в новый, и новый элемент добавляется. `len` увеличивается до 4, а `cap` становится 6.

Второй `append` добавляет два элемента (5 и 6). Теперь в слайсе есть место в текущей ёмкости (6).  Элементы просто добавляются в существующий базовый массив. `len` увеличивается до 6, а `cap` остается 6.
</details>

### Задача 2

```go
package main

import "fmt"

func modifySlice(s []int) {
	s[0] = 100
	s = append(s, 200)
}

func main() {
	s := []int{1, 2, 3}
	fmt.Println("Before modifySlice:", s)
	modifySlice(s)
	fmt.Println("After modifySlice:", s)
}
```

Task:  Проанализируйте код. Что будет выведено на экран? Объясните, почему вывод именно такой. Как ведет себя слайс при передаче в функцию?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**

Before modifySlice: [1 2 3]
After modifySlice: [100 2 3]

**Task Explanation:**

Слайсы передаются в функции по значению, но значением слайса является *дескриптор*, содержащий указатель на базовый массив, длину и ёмкость.

В функции `modifySlice`, когда выполняется `s[0] = 100`, изменяется элемент базового массива, на который указывает дескриптор `s`.  Так как и в `main`, и в `modifySlice` слайсы указывают на один и тот же базовый массив (до первого append в `modifySlice`), изменение `s[0]` в функции видно и в `main`.

Однако, когда в `modifySlice` выполняется `s = append(s, 200)`, если происходит переаллокация (а она может произойти, если, например, `cap` был равен `len`), то `s` внутри функции начинает указывать на *новый* базовый массив. Это изменение `s` (указателя на базовый массив) внутри `modifySlice` не влияет на слайс `s` в функции `main`, так как передача слайса происходит по значению (копируется дескриптор).  Если бы переаллокации не произошло (например, если бы изначально `cap` был больше `len`), то `append` мог бы произойти в существующем массиве, и тогда изменения могли бы быть видны *частично*, в зависимости от того, как слайс используется далее в `main`. В данном примере переаллокации, скорее всего, не происходит, так как начальный слайс имеет `cap` больше, чем `len` в типичных реализациях Go. Но важно понимать, что если бы capacity была бы равна length изначально, то `append` внутри функции привел бы к переаллокации и изменению дескриптора слайса внутри функции, что не повлияло бы на исходный слайс в `main`.

**Важно**: В данном конкретном примере, вероятно, переаллокации **не происходит**, так как Go часто выделяет capacity больше, чем length при создании слайса.  Но в общем случае, если capacity слайса `s` в `modifySlice` была бы равна `len(s)` перед `append`, то `append` привел бы к переаллокации.
</details>

### Задача 3

```go
package main

import "fmt"

func main() {
	s1 := []int{1, 2, 3, 4, 5}
	s2 := s1[1:3]

	fmt.Println("s1:", s1)
	fmt.Println("s2:", s2)

	s2[0] = 10

	fmt.Println("s1:", s1)
	fmt.Println("s2:", s2)

	s2 = append(s2, 20)

	fmt.Println("s1:", s1)
	fmt.Println("s2:", s2)

	s2 = append(s2, 30, 40)

	fmt.Println("s1:", s1)
	fmt.Println("s2:", s2)
}
```

Task: Проанализируйте код и предскажите вывод программы. Обратите внимание на взаимодействие между `s1` и `s2` после операций создания под-слайса и `append`.  Как `len` и `cap` меняются у `s2`?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**

s1: [1 2 3 4 5]
s2: [2 3]
s1: [1 10 3 4 5]
s2: [10 3]
s1: [1 10 20 4 5]
s2: [10 3 20]
s1: [1 10 20 4 5]
s2: [10 3 20 30 40]

**Task Explanation:**

1. **Инициализация:** `s1` создан как `[1 2 3 4 5]`. `s2` - под-слайс `s1[1:3]`, что означает элементы `s1` с индекса 1 (включительно) до 3 (исключительно). `s2` initially is `[2 3]`.  `s2` и `s1` разделяют общий базовый массив.

2. **Изменение через `s2`:** `s2[0] = 10` изменяет первый элемент `s2`. Так как `s2` и `s1` разделяют базовый массив, это изменение также видно через `s1` (элемент `s1[1]` становится 10).

3. **`append` к `s2` (первый):** `s2 = append(s2, 20)`.  Изначально `cap(s2)` был равен `cap(s1) - 1 = 4`. `len(s2)` был 2.  При добавлении `20`, есть место в `s2` (а значит и в общем базовом массиве). `20` добавляется в базовый массив после `3` (фактически, на позицию `s1[3]`, т.е. заменяя `4`).  `s2` теперь `[10 3 20]`, а `s1` стал `[1 10 3 20 5]`.

4. **`append` к `s2` (второй):** `s2 = append(s2, 30, 40)`. Теперь `len(s2)` был 3, а `cap(s2)` был 4.  Добавление еще двух элементов (30, 40) требует переаллокации для `s2`, так как места в текущем базовом массиве, *видимом через `s2`*, недостаточно.  `append` выделяет новый базовый массив для `s2` большей ёмкости.  Данные `[10 3 20]` копируются в новый массив, и добавляются `30` и `40`.  Теперь `s2` указывает на *новый* массив `[10 3 20 30 40]`, и больше не разделяет базовый массив с `s1`.  Поэтому последующие изменения `s2` не влияют на `s1`. `s1` остается `[1 10 20 4 5]`.

**Ключевой момент:**  `append` к под-слайсу может привести к переаллокации, в результате чего под-слайс перестанет разделять базовый массив с исходным слайсом. Это происходит, когда добавление элементов превышает текущую ёмкость под-слайса *в контексте исходного массива*.
</details>


### Задача 4

```go
package main

import "fmt"

func main() {
	var s1 []int
	s2 := make([]int, 0)
	s3 := []int{}

	fmt.Printf("s1: %v, len: %d, cap: %d, nil: %t\n", s1, len(s1), cap(s1), s1 == nil)
	fmt.Printf("s2: %v, len: %d, cap: %d, nil: %t\n", s2, len(s2), cap(s2), s2 == nil)
	fmt.Printf("s3: %v, len: %d, cap: %d, nil: %t\n", s3, len(s3), cap(s3), s3 == nil)
}
```

Task: Проанализируйте код и предскажите вывод программы. В чем разница между `nil` слайсом и пустым слайсом? Какие способы инициализации слайсов приводят к `nil` и пустым слайсам?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**

s1: [], len: 0, cap: 0, nil: true
s2: [], len: 0, cap: 0, nil: false
s3: [], len: 0, cap: 0, nil: false

**Task Explanation:**

* **`nil` слайс:**  `var s1 []int` объявляет слайс `s1` без инициализации. Значением `s1` является `nil`. `nil` слайс не имеет базового массива.  `len(s1)` и `cap(s1)` для `nil` слайса равны 0.  `s1 == nil` истинно.

* **Пустой слайс:** `s2 := make([]int, 0)` и `s3 := []int{}` создают пустые слайсы. Пустые слайсы *имеют* базовый массив (хоть и нулевой длины), но не являются `nil`.  `len(s2)` и `len(s3)` равны 0, `cap(s2)` и `cap(s3)` также могут быть 0 (зависит от реализации `make` с нулевой длиной и ёмкостью, в данном случае 0). `s2 == nil` и `s3 == nil` - ложны.

**Разница важна:** Хотя и `nil`, и пустые слайсы имеют длину 0 и во многих случаях ведут себя похоже, `nil` слайс означает "слайс не инициализирован", а пустой слайс означает "слайс инициализирован, но не содержит элементов".

**Когда это важно:**

* **JSON marshaling:**  `nil` слайс при JSON marshaling может быть представлен как `null`, а пустой слайс - как `[]`. В зависимости от ожиданий принимающей стороны, это может быть важным.
* **Функции, принимающие слайсы:** Некоторые функции могут по-разному обрабатывать `nil` и пустые слайсы. Например, функция, которая итерируется по слайсу, будет корректно работать с пустым слайсом (не выполнит итераций), но может вызвать панику при попытке итерации по `nil` слайсу (если не предусмотрена проверка на `nil`). Хотя итерация по `range` по nil слайсу является безопасной и просто не выполнит итераций.
* **Идиоматичный Go:** В большинстве случаев, когда функция возвращает слайс, предпочтительнее возвращать пустой слайс вместо `nil`, чтобы избежать необходимости проверки на `nil` со стороны вызывающего кода.  Если слайс должен представлять "отсутствие данных", то `nil` может быть уместен.  Но в целом, для представления "нулевого количества элементов" итерируемой коллекции, пустой слайс обычно предпочтительнее.

</details>


### Задача 5

```go
package main

import "fmt"

func main() {
	s := make([]int, 5, 10)
	fmt.Println("Initial:", s, len(s), cap(s))

	s = s[:cap(s)]
	fmt.Println("Extended to cap:", s, len(s), cap(s))

	s = s[:cap(s)+1]
	fmt.Println("New extended:", s, len(s), cap(s))
}
```

Task: Проанализируйте код. Какой будет вывод? Как правильно работать с длиной и ёмкостью слайса при создании под-слайсов?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**

Если раскомментировать строку `s = s[:cap(s)+1]`, программа вызовет панику `panic: runtime error: slice bounds out of range [::11] with capacity 10`.

**Task Explanation:**

1. **Инициализация:** `s := make([]int, 5, 10)` создает слайс `s` длиной 5 и ёмкостью 10.  Базовый массив содержит 10 элементов, из которых первые 5 доступны через слайс `s` и инициализированы значениями по умолчанию (в данном случае 0 для `int`).

2. **`s = s[:cap(s)]`:** Эта строка создает новый под-слайс `s`, который начинается с начала исходного слайса (индекс 0) и заканчивается индексом, равным ёмкости исходного слайса (исключительно).  Другими словами, она *расширяет* длину слайса до его ёмкости.  Теперь `len(s)` становится 10 (равно `cap(s)`), а `cap(s)` остается 10.  Слайс теперь "заполнен" всеми элементами, которые выделены в базовом массиве.

3. **`s = s[:cap(s)+1]` (ошибка):**  Эта строка пытается создать под-слайс, который выходит за пределы ёмкости базового массива.  Операция `s[:high]` паникует, если `high` больше, чем ёмкость слайса. В данном случае `cap(s)` равен 10, поэтому `cap(s)+1` равен 11.  Попытка создать слайс длиной 11, при ёмкости базового массива 10 приводит к ошибке "slice bounds out of range".

**Правила работы с длиной и ёмкостью при создании под-слайсов:**

* При создании под-слайса `s[low:high]`,  индекс `low` должен быть в диапазоне `[0, len(s)]`, а индекс `high` должен быть в диапазоне `[low, cap(s)]`.
* Длина нового под-слайса будет `high - low`.
* Ёмкость нового под-слайса будет `cap(s) - low`.
* Никогда нельзя создавать под-слайс, выходящий за пределы ёмкости исходного слайса.  `high` индекс *может* быть равен `cap(s)`, но не может быть больше.
* Часто для "расширения" слайса до его ёмкости используется идиома `s = s[:cap(s)]`.

Понимание границ слайсов (`len` и `cap`) критически важно для избежания паник и корректной работы с памятью в Go.
</details>


### Задача 6

```go
package main

import (
	"fmt"
	"time"
)

func generateData() []int {
	data := make([]int, 1000000)
	for i := range data {
		data[i] = i
	}
	return data
}

func processData(data []int) []int {
	// some processing, creating a smaller slice
	if len(data) > 100 {
		return data[:100]
	}
	return data
}

func main() {
	startTime := time.Now()
	data := generateData()
	processedData := processData(data)

	// time.Sleep(10 * time.Second) // uncomment to observe memory

	fmt.Printf("Processed data length: %d\n", len(processedData))
	fmt.Printf("Time taken: %s\n", time.Since(startTime))

	// Force GC to see if memory is released quickly (may not be reliable)
	// runtime.GC()
	// fmt.Println("GC called")

	// Keep main function running for a while to observe memory in profiler/task manager
	time.Sleep(30 * time.Second) // observe memory usage
}
```

Task: Проанализируйте код на предмет потенциальных утечек памяти, связанных со слайсами.  Что происходит с памятью, выделенной в `generateData()`, после вызова `processData()`?  Как можно избежать потенциальной утечки, если `processData()` возвращает маленький под-слайс большого исходного слайса? Раскомментируйте `time.Sleep(10 * time.Second)` и запустите программу, наблюдая за использованием памяти.

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer and Task Explanation:**

**Потенциальная утечка памяти:**

Проблема в функции `processData()`. Она принимает большой слайс `data` и возвращает *под-слайс* этого слайса (`data[:100]`).  **Важно:** Под-слайс `data[:100]` продолжает *указывать на тот же самый базовый массив*, что и исходный большой слайс `data`.

Даже если `processedData` содержит только 100 элементов, базовый массив, на который он ссылается, по-прежнему имеет размер, необходимый для хранения 1,000,000 элементов, выделенных в `generateData()`.

До тех пор, пока `processedData` (и, следовательно, его базовый массив) достижим (т.е., на него есть ссылки в программе, в данном случае переменная `processedData` в `main`), garbage collector (GC) не сможет освободить память, занятую большим базовым массивом.  Это и есть потенциальная утечка памяти.  Мы "держим" в памяти большой массив, хотя используем только маленькую его часть через под-слайс.

**Как избежать утечки:**

Чтобы избежать утечки, нужно **скопировать** данные из под-слайса в новый слайс, который будет иметь собственный, меньший базовый массив.  Это можно сделать, например, с помощью `copy` или `append` к новому слайсу:

```go
func processDataFixed(data []int) []int {
	if len(data) > 100 {
		// Способ 1: Использование copy
		// result := make([]int, 100)
		// copy(result, data[:100])
		// return result

		// Способ 2: Использование append к пустому слайсу
		result := append([]int{}, data[:100]...) // "..." распаковывает под-слайс
		return result
	}
	return data
}
```

В исправленной версии processDataFixed(), создается новый слайс (result). При использовании copy, данные из data[:100] копируются в новый базовый массив result. При использовании append к пустому слайсу, происходит аналогичное: append создаст новый базовый массив для result и скопирует туда данные.

После изменения функции на processDataFixed, processedData будет указывать на новый слайс с базовым массивом размера 100 (или около того, в зависимости от ёмкости, выделенной make или append), и большой базовый массив, выделенный в generateData, станет недостижимым (если на него больше нет ссылок) и будет освобожден GC.

Наблюдение за памятью:

Исходный код (processData): Если запустить программу с исходной функцией processData и раскомментировать time.Sleep(10 * time.Second), и затем time.Sleep(30 * time.Second), можно заметить (например, через task manager или инструменты профилирования), что память, выделенная для большого слайса, не освобождается быстро. Даже после завершения функции generateData() и processData(), память продолжает удерживаться.

Исправленный код (processDataFixed): Если заменить processData на processDataFixed и повторить запуск с задержками, можно увидеть, что память освобождается значительно быстрее, так как большой базовый массив больше не удерживается под-слайсом.

Вывод: Под-слайсы - мощный и эффективный инструмент, но важно помнить, что они разделяют базовый массив с исходным слайсом. Если под-слайс значительно меньше исходного слайса, и исходный слайс больше не нужен, необходимо обеспечить, чтобы под-слайс не удерживал в памяти весь большой базовый массив. Копирование данных в новый слайс - распространенный способ решения этой проблемы для предотвращения утечек памяти в Go.

</details>

















### Задача 7

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

type User struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

func processUsers(userJSON []byte) ([]string, error) {
	var users []User
	err := json.Unmarshal(userJSON, &users)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal users: %w", err)
	}

	if len(users) == 0 {
		return []string{}, nil // Return empty slice, not nil, if no users
	}

	names := make([]string, 0, len(users))

	for _, user := range users {
		if user.ID > 0 { // Basic data validation
			names = append(names, user.Name)
		}
	}
	return names, nil
}

func main() {
	validJSON := []byte(`[{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}, {"id": 0, "name": "Invalid"}]`)
	invalidJSON := []byte(`invalid json`)

	names1, err1 := processUsers(validJSON)
	if err1 != nil {
		log.Fatalf("Error processing valid JSON: %v", err1)
	}
	fmt.Println("Valid users names:", names1)

	names2, err2 := processUsers(invalidJSON)
	if err2 != nil {
		fmt.Println("Error processing invalid JSON:", err2)
	} else {
		fmt.Println("Invalid JSON names (should be error):", names2)
	}

	emptyJSON := []byte(`[]`)
	names3, err3 := processUsers(emptyJSON)
	if err3 != nil {
		log.Fatalf("Error processing empty JSON: %v", err3)
	}
	fmt.Println("Empty JSON names:", names3)


	nilJSON := []byte(`null`)
	names4, err4 := processUsers(nilJSON)
	if err4 != nil {
		fmt.Println("Error processing nil JSON:", err4)
	} else {
		fmt.Println("Nil JSON names (unexpectedly no error?):", names4) // Consider what happens when JSON is 'null'
	}
}
```

Task: Проанализируйте функцию `processUsers`.  Предскажите вывод программы для различных входных JSON (`validJSON`, `invalidJSON`, `emptyJSON`, `nilJSON`). Обратите внимание на обработку ошибок, пустых слайсов и потенциальную ситуацию с `nil` slice после unmarshal.  В каких случаях функция вернет `nil` слайс, а в каких - пустой?  Почему в коде используется `make([]string, 0, len(users))` для инициализации слайса `names`?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**


Valid users names: [Alice Bob]
Error processing invalid JSON: failed to unmarshal users: invalid character 'i' looking for beginning of value
Empty JSON names: []
Error processing nil JSON: failed to unmarshal users: json: cannot unmarshal null into Go value of type []main.User

**Task Explanation:**

1.  **`validJSON`:** JSON успешно unmarshalled в слайс `users`.  Функция фильтрует пользователей с `ID > 0` и извлекает их имена в слайс `names`.  Выводится `[Alice Bob]`. Инициализация `names := make([]string, 0, len(users))` с предварительным выделением capacity (равным длине `users`) является хорошей практикой для оптимизации, чтобы избежать переаллокаций при множественных `append`.

2.  **`invalidJSON`:**  `json.Unmarshal` возвращает ошибку, так как JSON невалидный. Функция `processUsers` корректно обрабатывает ошибку и возвращает `nil` слайс и ошибку. Ошибка печатается на экран.

3.  **`emptyJSON` (`[]`):**  JSON `[]` успешно unmarshalled в пустой слайс `users` (длиной 0).  Условие `len(users) == 0` выполняется. Функция *возвращает пустой слайс* `[]string{}` (не `nil`) и `nil` ошибку.  Это важный момент: функция явно возвращает пустой слайс в случае пустого входного JSON, а не `nil`.

4.  **`nilJSON` (`null`):**  JSON `null` при попытке unmarshal в `[]User` вызывает ошибку `json: cannot unmarshal null into Go value of type []main.User`.  По умолчанию, `json.Unmarshal` не может unmarshal JSON `null` в слайс.  Функция `processUsers` обрабатывает эту ошибку и возвращает `nil` слайс и ошибку.

**Ключевые моменты:**

*   Функция `processUsers` *никогда не возвращает `nil` слайс в случае успешного выполнения*. В случае успеха, она возвращает либо слайс с именами, либо *пустой слайс* `[]string{}` если входной JSON был пуст или не содержал валидных пользователей.  Ошибка возвращается вместе с `nil` слайсом только при ошибке unmarshal или другой критической проблеме.
*   Предварительное выделение capacity в `names := make([]string, 0, len(users))` является оптимизацией, особенно если ожидается, что количество имен будет близко к количеству пользователей. Это помогает избежать лишних переаллокаций памяти при `append` в цикле.
*   Обработка ошибок `json.Unmarshal` важна для надежной работы. Функция корректно проверяет ошибку и возвращает ее.
*   Поведение unmarshal JSON `null` в слайсы может быть неожиданным. В данном случае, стандартный `json.Unmarshal` выдает ошибку, что является разумным поведением, так как `null` не является корректным представлением слайса `User`-ов. Если бы требовалось обрабатывать `null` как пустой слайс, потребовалась бы кастомная логика unmarshal или проверка на `null` до unmarshal.


**Почему `make([]string, 0, len(users))`:**

Инициализация `names := make([]string, 0, len(users))` создает слайс строк с длиной 0 и ёмкостью, равной длине `users`.  Это делается для оптимизации производительности.  Когда вы используете `append` в цикле, Go может потребоваться переаллоцировать базовый массив слайса несколько раз, если слайс начинает заполняться, а его ёмкость исчерпывается.  Предварительное выделение ёмкости помогает избежать этих переаллокаций, если заранее известно приблизительное количество элементов, которые будут добавлены (в данном случае, не более чем `len(users)`).  Если бы capacity не была задана (`make([]string, 0)`), Go бы динамически увеличивал ёмкость при каждом `append`, когда текущая ёмкость исчерпана, что может быть менее эффективно, особенно для больших слайсов.
</details>


### Задача 8

```go
package main

import "fmt"

type Product struct {
	ID    int
	Name  string
	Price float64
}

func filterAndTransformProducts(products []Product, priceThreshold float64) []string {
	filteredProducts := make([]Product, 0)
	for _, p := range products {
		if p.Price >= priceThreshold {
			filteredProducts = append(filteredProducts, p)
		}
	}

	names := make([]string, len(filteredProducts))
	for i, p := range filteredProducts {
		names[i] = p.Name + fmt.Sprintf(" (%.2f)", p.Price)
	}
	return names
}

func main() {
	products := []Product{
		{ID: 1, Name: "Laptop", Price: 1200.00},
		{ID: 2, Name: "Mouse", Price: 25.00},
		{ID: 3, Name: "Keyboard", Price: 75.00},
		{ID: 4, Name: "Monitor", Price: 300.00},
		{ID: 5, Name: "USB Cable", Price: 5.00},
	}

	expensiveProducts := filterAndTransformProducts(products, 100.00)
	fmt.Println("Expensive products:", expensiveProducts)

	cheapProducts := filterAndTransformProducts(products, 500.00)
	fmt.Println("Cheap products (above $500):", cheapProducts)

	allProducts := filterAndTransformProducts(products, 0.00)
	fmt.Println("All products:", allProducts)

	noProducts := filterAndTransformProducts([]Product{}, 100.00)
	fmt.Println("No products input:", noProducts)
}
```

Task: Проанализируйте функцию `filterAndTransformProducts`.  Предскажите вывод программы. Есть ли потенциальная ошибка или неэффективность в инициализации слайса `names`?  Как можно улучшить код, особенно в части инициализации `names` и общей логики функции, сделав его более идиоматичным и эффективным?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**

Expensive products: [Laptop (1200.00) Monitor (300.00)]
Cheap products (above $500): []
All products: [Laptop (1200.00) Mouse (25.00) Keyboard (75.00) Monitor (300.00) USB Cable (5.00)]
No products input: []

**Task Explanation:**

1.  **Фильтрация:** Функция сначала фильтрует продукты, цена которых равна или превышает заданный порог `priceThreshold`, и сохраняет их в слайсе `filteredProducts`.

2.  **Трансформация:** Затем функция создает слайс `names`, предназначенный для хранения имен отфильтрованных продуктов в определенном формате. **Здесь и есть потенциальная проблема:**  `names := make([]string, len(filteredProducts))`.  Эта строка создает слайс `names` *с длиной, равной длине `filteredProducts`*.  Это означает, что `names` уже инициализирован *пустыми строками* (или нулевыми значениями для типа `string`).

3.  **Запись в `names`:** В цикле `for i, p := range filteredProducts`, значения записываются в `names` по индексу (`names[i] = ...`). Это *заменяет* изначально пустые строки в `names` на нужные значения.

**Потенциальная неэффективность и ошибка (стилистическая/семантическая):**

*   **Инициализация `names` с длиной:**  Инициализация `names := make([]string, len(filteredProducts))` не является ошибкой в строгом смысле, но это *не идиоматично* и потенциально менее эффективно в данном контексте.  Когда вы заранее не знаете точное количество элементов, которые будут добавлены в слайс (что часто бывает при фильтрации), лучше инициализировать слайс с нулевой длиной и, возможно, с ёмкостью, если есть примерное представление о размере. В данном случае,  `len(filteredProducts)` на момент инициализации `names` *не известно* заранее (оно становится известно только после завершения цикла фильтрации).

*   **Более идиоматичный и эффективный подход:**  Лучше инициализировать `names` как *пустой слайс* с возможностью динамического расширения через `append`.

**Улучшенный код:**

```go
func filterAndTransformProductsImproved(products []Product, priceThreshold float64) []string {
	filteredProducts := make([]Product, 0)
	for _, p := range products {
		if p.Price >= priceThreshold {
			filteredProducts = append(filteredProducts, p)
		}
	}

	names := make([]string, 0, len(filteredProducts)) // Инициализация с capacity для оптимизации, но длина 0
	for _, p := range filteredProducts { // Range over filteredProducts directly
		names = append(names, p.Name + fmt.Sprintf(" (%.2f)", p.Price)) // Append to names
	}
	return names
}
```

**Или еще более кратко и идиоматично:**

```go
func filterAndTransformProductsConcise(products []Product, priceThreshold float64) []string {
	names := make([]string, 0) // Пустой слайс, без capacity hint в данном примере для краткости
	for _, p := range products {
		if p.Price >= priceThreshold {
			names = append(names, p.Name + fmt.Sprintf(" (%.2f)", p.Price))
		}
	}
	return names
}
```

В улучшенных версиях:

*   `names` инициализируется как `make([]string, 0, len(filteredProducts))` или `make([]string, 0)`.  Длина 0, capacity может быть задана для оптимизации.
*   Второй цикл теперь использует `range` по `filteredProducts` и напрямую `append`-ит отформатированные имена в `names`.  Это более прямолинейно и эффективно, так как избегает излишней предварительной инициализации `names` с фиксированной длиной и последующей замены элементов.

**Ключевой момент:**  При работе со слайсами, особенно когда количество элементов результата неизвестно заранее (как при фильтрации),  инициализируйте результирующий слайс как *пустой* (длина 0) и используйте `append` для добавления элементов.  Предварительное выделение capacity (`make([]T, 0, capacity)`) может быть полезно для оптимизации, если приблизительная ёмкость известна, но длина должна начинаться с 0, если слайс будет расти динамически через `append`.
</details>


### Задача 9

```go
package main

import "fmt"

type Order struct {
	ID       int
	Items    []string
	Discounts []float64
}

func applyDiscount(order *Order, discount float64) {
	order.Discounts = append(order.Discounts, discount)
	if len(order.Items) > 0 {
		order.Items[0] = order.Items[0] + " (discounted)" // Modify item in slice
	}
}

func main() {
	order1 := Order{
		ID:    101,
		Items: []string{"Product A", "Product B"},
		Discounts: []float64{0.05},
	}

	order2 := order1 // Copy struct

	applyDiscount(&order1, 0.10)

	fmt.Println("Order 1:", order1)
	fmt.Println("Order 2 (copy):", order2) // What will be here?
}
```

Task: Проанализируйте код. Что будет выведено для `order1` и `order2`? Объясните, почему вывод именно такой, особенно в отношении полей `Items` и `Discounts`. Как копирование структуры `Order` влияет на слайсы внутри нее?  В чем разница между копированием структуры, содержащей слайс, и копированием самого слайса?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer:**

Order 1: {101 [Product A (discounted) Product B] [0.05 0.1]}
Order 2 (copy): {101 [Product A (discounted) Product B] [0.05]}

**Task Explanation:**

1.  **Инициализация `order1`:**  Создается структура `order1` с полями `Items` и `Discounts`, являющимися слайсами.

2.  **Копирование структуры `order2 := order1`:**  При присваивании `order2 := order1`, создается *копия структуры* `order1`. Это означает, что значения полей (включая *дескрипторы слайсов*) копируются в `order2`.  **Важно:**  *Сами базовые массивы слайсов `Items` и `Discounts` *не копируются*.  Оба `order1.Items` и `order2.Items` будут указывать на *один и тот же базовый массив* для товаров, и аналогично, `order1.Discounts` и `order2.Discounts` *начнут* указывать на один и тот же базовый массив для скидок (до первого append).

3.  **`applyDiscount(&order1, 0.10)`:**  Функция `applyDiscount` вызывается *для `order1`* (передается указатель).

    *   `order.Discounts = append(order.Discounts, discount)`:  К слайсу `order1.Discounts` добавляется скидка `0.10`.  **Здесь происходит append.**  Так как исходный слайс `order1.Discounts` имел ёмкость, скорее всего, append произойдет в существующем базовом массиве (без переаллокации на первом append).  Поэтому, `order1.Discounts` теперь `[0.05 0.10]`.  И так как `order2.Discounts` изначально указывал на тот же базовый массив, `order2.Discounts` также *видит изменение*  и потенциально мог бы отразить `[0.05 0.10]`, если бы не было дальнейшего переназначения `order1.Discounts`. Но, из-за особенностей реализации `append` и возможной переаллокации на последующих append-ах (если бы их было больше),  точная синхронизация между `order1.Discounts` и `order2.Discounts` после нескольких `append` может быть неочевидной и зависеть от реализации.  В данном примере, скорее всего, после первого `append`, `order1.Discounts` *и* `order2.Discounts` все еще могут частично разделять общий базовый массив, но важно понимать, что последующие `append` на `order1.Discounts` могут привести к переаллокации *для `order1.Discounts`*, и разделение базового массива с `order2.Discounts` может быть прекращено.

    *   `order.Items[0] = order.Items[0] + " (discounted)"`:  Изменяется *первый элемент* слайса `order1.Items`.  Так как `order1.Items` и `order2.Items` разделяют общий базовый массив, это изменение *видно и через `order2.Items`*.  Поэтому, `order1.Items[0]` и `order2.Items[0]` оба становятся `"Product A (discounted)"`.

4.  **Вывод:** При выводе `order1` и `order2`, мы видим:

    *   `order1.Discounts` содержит `[0.05 0.1]`, как и ожидалось после `append`.
    *   `order2.Discounts` содержит `[0.05]`.  *Здесь важно уточнение*:  на момент копирования структуры, `order2.Discounts` указывал на тот же базовый массив, что и `order1.Discounts`.  После первого `append` в `applyDiscount`,  вероятно, изменения в базовом массиве `Discounts` видны *обоим* структурам (т.е., `order2.Discounts` тоже мог бы показывать `[0.05 0.1]` на этом этапе).  Однако, важно понимать, что дальнейшие `append` к `order1.Discounts` *могут* привести к переаллокации базового массива *только для `order1.Discounts`*,  и связь с `order2.Discounts` будет разорвана.  В данном примере, поскольку append всего один раз и исходной capacity могло хватить, они могли бы частично разделять массив даже после append.  Но суть в том, что  разделение базового массива не гарантирует, что изменения через `append` к одному слайсу *всегда* будут видны через другой, особенно после нескольких операций append.
    *   `order1.Items` и `order2.Items` оба содержат `["Product A (discounted)", "Product B"]`, потому что изменение `order1.Items[0]` напрямую изменяет элемент в общем базовом массиве, который виден обоим слайсам.

**Разница между копированием структуры со слайсом и копированием слайса:**

*   **Копирование структуры:** Копирует значения полей структуры, включая *дескрипторы* слайсов.  Базовые массивы слайсов *не копируются* (по крайней мере, изначально - до возможных переаллокаций при `append`).  Несколько структур могут разделять базовые массивы слайсов. Изменение элемента слайса через одну структуру будет видно через другую структуру, если они разделяют базовый массив.  Операции `append` могут привести к переаллокации и разрыву этого разделения для конкретного слайса.

*   **Копирование слайса (например, `sliceCopy := append([]T{}, originalSlice...)` или `copy`)**: Создает *новый слайс* с *новым базовым массивом*.  Данные из исходного слайса *копируются* в новый массив.  Изменения в новом слайсе не влияют на исходный слайс, и наоборот, так как они работают с разными базовыми массивами.

**В заключение:** Копирование структуры, содержащей слайсы, не делает "глубокую копию" слайсов. Слайсы внутри скопированной структуры продолжают указывать на те же базовые массивы, что и слайсы в исходной структуре (до тех пор, пока `append` не вызовет переаллокацию для одного из них).  Это важно понимать при работе со структурами, содержащими слайсы, особенно когда планируется изменять данные через разные "копии" структуры.
</details>











### Задача 10

```go
package main

import "fmt"

func processItems(itemNames []string) []string {
	result := []string{}

	for _, name := range itemNames {
		processedName := fmt.Sprintf("Item: %s", name)
		result = append(result, processedName)
	}
	return result
}

func main() {
	items := []string{"Apple", "Banana", "Orange", "Grape", "Mango", "Pineapple", "Watermelon"}
	processedItems := processItems(items)
	fmt.Println("Processed items:", processedItems)

	largeItemsList := make([]string, 1000)
	for i := range largeItemsList {
		largeItemsList[i] = fmt.Sprintf("Item-%d", i)
	}
	processedLargeItems := processItems(largeItemsList)
	fmt.Printf("Processed large list, length: %d\n", len(processedLargeItems))
}
```

Task: Проанализируйте функцию `processItems`.  В чем заключается неэффективность данного кода, особенно при обработке большого количества элементов?  **Рефакторинг**: Модифицируйте функцию `processItems` так, чтобы она работала более эффективно, особенно для больших входных слайсов, минимизируя количество переаллокаций памяти. Объясните, какие изменения вы внесли и почему они улучшают производительность.

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer - Refactored Code:**

```go
package main

import "fmt"

func processItemsRefactored(itemNames []string) []string {
	result := make([]string, 0, len(itemNames)) // Pre-allocate capacity

	for _, name := range itemNames {
		processedName := fmt.Sprintf("Item: %s", name)
		result = append(result, processedName)
	}
	return result
}

func main() {
	items := []string{"Apple", "Banana", "Orange", "Grape", "Mango", "Pineapple", "Watermelon"}
	processedItems := processItemsRefactored(items)
	fmt.Println("Processed items:", processedItems)

	largeItemsList := make([]string, 1000)
	for i := range largeItemsList {
		largeItemsList[i] = fmt.Sprintf("Item-%d", i)
	}
	processedLargeItems := processItemsRefactored(largeItemsList)
	fmt.Printf("Processed large list, length: %d\n", len(processedLargeItems))
}
```

**Task Explanation (Refactoring and Performance Improvement):**

**Проблема неэффективности:**

В исходной функции `processItems`, слайс `result` инициализируется как `[]string{}`.  Это создает пустой слайс с длиной и ёмкостью 0.  В цикле `for`, при каждом `append` к `result`, если текущей ёмкости недостаточно, Go должен переаллоцировать базовый массив для `result`, скопировать существующие элементы, и только потом добавить новый элемент.  Когда количество элементов велико, эти переаллокации и копирования происходят многократно, что приводит к снижению производительности, особенно по времени и потреблению памяти.  Это называется "квадратичная сложность" в худшем случае для append, хотя Go's growth factor is designed to amortize this.

**Решение - Предварительное выделение ёмкости (Capacity Pre-allocation):**

В рефакторинге `processItemsRefactored`, слайс `result` инициализируется с использованием `make([]string, 0, len(itemNames))`.  Здесь мы указываем *начальную ёмкость* равной длине входного слайса `itemNames`.  Мы знаем, что результирующий слайс будет иметь как минимум столько же элементов, сколько и входной.

**Преимущества рефакторинга:**

*   **Минимизация переаллокаций:**  Предварительное выделение ёмкости *резко уменьшает* или *полностью исключает* необходимость переаллокаций базового массива во время цикла `append` (в большинстве случаев, если количество добавляемых элементов не превышает capacity).  Go может теперь добавлять элементы в `result` в основном просто записывая их в уже выделенное пространство памяти.
*   **Улучшение производительности:**  Уменьшение переаллокаций приводит к значительной экономии времени и ресурсов CPU, особенно для больших входных слайсов. Программа работает быстрее и эффективнее по памяти.
*   **Идиоматичность Go:** Предварительное выделение ёмкости, когда размер слайса известен заранее или может быть разумно оценен, является хорошей практикой и идиоматичным подходом в Go для оптимизации работы со слайсами.

**Когда это важно:**  Предварительное выделение ёмкости наиболее критично в ситуациях, когда вы *многократно* добавляете элементы к слайсу в цикле, особенно если слайс потенциально может стать большим.  Для небольших слайсов или операций `append`, которые выполняются нечасто, эффект от предварительного выделения capacity может быть менее заметным, но в общем случае это хорошая привычка.
</details>


### Задача 11

```go
package main

import "fmt"

func duplicateItems(items []int) []int {
	duplicated := make([]int, len(items))
	copy(duplicated, items)

	for i := range duplicated {
		duplicated[i] *= 2
	}
	return duplicated
}

func processData(data []int) []int {
	modifiedData := duplicateItems(data)

	finalResult := make([]int, 0)
	for _, val := range modifiedData {
		if val > 10 {
			finalResult = append(finalResult, val)
		}
	}
	return finalResult
}


func main() {
	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	result := processData(data)
	fmt.Println("Final result:", result)
}
```

Task: Проанализируйте функции `duplicateItems` и `processData`. В чем заключается потенциальная избыточность или неэффективность в функции `duplicateItems` в контексте того, как она используется в `processData`? **Рефакторинг**: Модифицируйте функции так, чтобы избежать ненужного копирования данных, сохраняя при этом логику обработки.  Опишите, какие изменения вы внесли и почему это улучшение.  Может ли функция `duplicateItems` быть вообще устранена или изменена так, чтобы улучшить общий код?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer - Refactored Code:**

```go
package main

import "fmt"

func processDataRefactored(data []int) []int {
	// Modified to directly process and modify data in place, if appropriate
	modifiedData := data // No explicit duplication needed now

	for i := range modifiedData {
		modifiedData[i] *= 2 // Modify original data slice directly
	}

	// Some processing step 2 (further process the modified data)
	finalResult := make([]int, 0)
	for _, val := range modifiedData {
		if val > 10 {
			finalResult = append(finalResult, val)
		}
	}
	return finalResult
}


func main() {
	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	// Create a copy if original data needs to be preserved
	dataCopy := make([]int, len(data))
	copy(dataCopy, data)

	result := processDataRefactored(dataCopy) // Pass the copy to refactored function
	fmt.Println("Final result:", result)
	fmt.Println("Original data (preserved):", data) // Verify original data is unchanged
}
```

**Task Explanation (Refactoring - Avoiding Unnecessary Copying):**

**Проблема избыточного копирования:**

В исходном коде функция `duplicateItems` создает *полную копию* входного слайса `items` в слайс `duplicated` и затем модифицирует *копию*.  В контексте `processData`, `duplicateItems` используется для создания модифицированной версии `data`, которая затем обрабатывается дальше.

**Неэффективность:**  Создание полной копии слайса может быть ресурсоемким, особенно для больших слайсов.  В данном сценарии, функция `processData` *не использует* исходный, немодифицированный слайс `data` после вызова `duplicateItems`.  Ей нужен только *модифицированный* набор данных.  Таким образом, копирование всего слайса в `duplicateItems` становится избыточным копированием, если мы можем модифицировать данные "на месте" (in-place).

**Решение - Модификация на месте (In-place Modification) и устраненение `duplicateItems`:**

В рефакторинге `processDataRefactored`, функция `duplicateItems` *полностью устранена*. Логика "дублирования" (в смысле умножения на 2) теперь *встроена непосредственно в `processDataRefactored`*.

Вместо создания копии, `processDataRefactored` теперь *работает непосредственно с входным слайсом `data`* (или с копией, если это необходимо, как показано в `main`).  Цикл `for i := range modifiedData` модифицирует элементы слайса *напрямую*.

**Когда нужно копировать и когда можно модифицировать на месте:**

*   **Модификация на месте (In-place Modification) уместна, если:**
    *   Функция *не обязана* сохранять исходные данные.
    *   Производительность критична, и копирование больших объемов данных является узким местом.
*   **Копирование слайса необходимо, если:**
    *   Исходный слайс *должен быть сохранен* нетронутым для дальнейшего использования в вызывающем коде или в других частях алгоритма.
    *   Функция должна вернуть *новую, независимую* коллекцию данных, не изменяя входные данные.

**В данном примере,**  если бы `processData` требовалось сохранить исходный слайс `data` для дальнейших операций, то копирование было бы необходимым.  Однако, если, как в исходном примере, `processData` просто генерирует результат на основе *модифицированной* версии данных и не использует исходные данные далее, то модификация на месте становится более эффективным решением.

**В refactored `main`:** Показан пример, как можно *явно создать копию* слайса `data` *в `main`* (`dataCopy := ...`) и передать копию в `processDataRefactored`, если вдруг возникнет требование *сохранить исходный `data`*. Это делает refactored код более гибким: выбор, копировать или модифицировать на месте, перемещается на уровень вызывающего кода, в зависимости от конкретных потребностей.
</details>


### Задача 12

```go
package main

import "fmt"

func filterPositive(numbers []int) []int {
	positiveNumbers := make([]int, 0)
	for _, num := range numbers {
		if num > 0 {
			positiveNumbers = append(positiveNumbers, num)
		}
	}
	return positiveNumbers
}

func main() {
	data := []int{-2, 5, -8, 10, 0, -3, 7, 1}
	positiveData := filterPositive(data)
	fmt.Println("Positive numbers:", positiveData)

	largeData := make([]int, 1000)
	for i := range largeData {
		if i%2 == 0 {
			largeData[i] = i
		} else {
			largeData[i] = -i
		}
	}
	filteredLargeData := filterPositive(largeData)
	fmt.Printf("Filtered large list, length: %d\n", len(filteredLargeData))
}
```

Task: Проанализируйте функцию `filterPositive`.  Хотя она функционально верна, есть ли способ сделать фильтрацию более эффективной, особенно если нужно *изменить исходный слайс* на месте (in-place) вместо создания нового слайса? **Рефакторинг**:  Предложите два варианта рефакторинга:
1.  Вариант 1:  Рефакторинг с использованием "in-place" фильтрации, изменяя исходный слайс `numbers` непосредственно (если это приемлемо по условиям задачи).
2.  Вариант 2:  Рефакторинг, который по-прежнему создает *новый слайс* с отфильтрованными значениями, но делает это более эффективно, используя, возможно, функцию `copy` и слайс operations.

Опишите преимущества и недостатки каждого варианта. Какой вариант может быть предпочтительнее в разных ситуациях?

<details>
  <summary>Spoiler (click to reveal)</summary>

**Correct Answer - Refactored Code (Variant 1 - In-place Filtering):**

```go
package main

import "fmt"

func filterPositiveInPlace(numbers []int) []int {
	i := 0 // Index for "positive" numbers in the modified slice
	for _, num := range numbers {
		if num > 0 {
			numbers[i] = num // Overwrite element at index 'i' with positive number
			i++
		}
	}
	return numbers[:i] // Return slice of only positive numbers, using slicing
}


func main() {
	data := []int{-2, 5, -8, 10, 0, -3, 7, 1}
	positiveDataInPlace := filterPositiveInPlace(data)
	fmt.Println("Positive numbers (in-place):", positiveDataInPlace)
	fmt.Println("Original data (modified):", data) // Original data IS modified

	largeData := make([]int, 1000)
	for i := range largeData {
		if i%2 == 0 {
			largeData[i] = i
		} else {
			largeData[i] = -i
		}
	}
	filteredLargeDataInPlace := filterPositiveInPlace(largeData)
	fmt.Printf("Filtered large list (in-place), length: %d\n", len(filteredLargeDataInPlace))
	// Original largeData is also modified
}
```

**Correct Answer - Refactored Code (Variant 2 - Efficient Copying with `copy`):**

```go
package main

import "fmt"

func filterPositiveCopyEfficient(numbers []int) []int {
	positiveNumbers := make([]int, 0, len(numbers)) // Pre-allocate up to the input size
	for _, num := range numbers {
		if num > 0 {
			positiveNumbers = append(positiveNumbers, num)
		}
	}
	// If the number of positive numbers is significantly less than len(numbers), we can re-slice to reclaim capacity (optional optimization)
	// positiveNumbers = positiveNumbers[:len(positiveNumbers)] // This is usually not needed

	return positiveNumbers
}


func filterPositiveCopyEfficient2(numbers []int) []int {
	positiveCount := 0
	for _, num := range numbers {
		if num > 0 {
			positiveCount++
		}
	}
	positiveNumbers := make([]int, positiveCount) // Allocate exactly the needed size
	index := 0
	for _, num := range numbers {
		if num > 0 {
			positiveNumbers[index] = num
			index++
		}
	}
	return positiveNumbers
}


func main() {
	data := []int{-2, 5, -8, 10, 0, -3, 7, 1}
	positiveDataCopyEfficient := filterPositiveCopyEfficient(data)
	fmt.Println("Positive numbers (copy efficient):", positiveDataCopyEfficient)
	// Original data is NOT modified

	positiveDataCopyEfficient2 := filterPositiveCopyEfficient2(data)
	fmt.Println("Positive numbers (copy efficient 2):", positiveDataCopyEfficient2)

	largeData := make([]int, 1000)
	for i := range largeData {
		if i%2 == 0 {
			largeData[i] = i
		} else {
			largeData[i] = -i
		}
	}
	filteredLargeDataCopyEfficient := filterPositiveCopyEfficient(largeData)
	fmt.Printf("Filtered large list (copy efficient), length: %d\n", len(filteredLargeDataCopyEfficient))

	filteredLargeDataCopyEfficient2 := filterPositiveCopyEfficient2(largeData)
	fmt.Printf("Filtered large list (copy efficient 2), length: %d\n", len(filteredLargeDataCopyEfficient2))

}
```


**Task Explanation (Refactoring - Optimizing Filtering):**

**Original `filterPositive` (using `append`):**  Функция создает новый слайс `positiveNumbers` и использует `append` для добавления положительных чисел. Это создает новый слайс, но может быть не самым эффективным способом, особенно если нужно изменить исходный слайс или если можно оптимизировать создание нового слайса.

**Вариант 1: In-place filtering (`filterPositiveInPlace`):**

*   **Логика:** Функция `filterPositiveInPlace` *изменяет исходный слайс `numbers` непосредственно*. Она использует два индекса: неявный индекс `range` и явный индекс `i`.  `i` отслеживает позицию для записи *положительных* чисел.  Когда встречается положительное число, оно *перезаписывает* элемент в `numbers[i]`, и `i` инкрементируется. После цикла, функция возвращает *под-слайс* `numbers[:i]`, который содержит только положительные числа в начале исходного слайса. Элементы после индекса `i` в исходном слайсе становятся нерелевантными, так как возвращен только под-слайс до `i`.

*   **Преимущества:**
    *   **Нулевое выделение дополнительной памяти (для слайса результата):**  In-place фильтрация *не создает нового слайса для результата* (только под-слайс исходного).  Это может быть очень эффективно по памяти, особенно для больших слайсов.
    *   **Быстрее (потенциально):**  Избегает выделения и копирования памяти для нового слайса.
*   **Недостатки:**
    *   **Изменяет исходный слайс:**  Исходный слайс `numbers` *модифицируется*.  Это может быть нежелательно, если исходные данные нужно сохранить. Функция `filterPositiveInPlace` имеет *побочный эффект*.
    *   **Порядок элементов может быть изменен:** Если порядок элементов важен, in-place фильтрация может его изменить (хотя в данном случае, порядок *положительных* чисел сохраняется относительно друг друга).

**Вариант 2: Efficient Copying (`filterPositiveCopyEfficient` and `filterPositiveCopyEfficient2`):**

*   **`filterPositiveCopyEfficient`:** Использует предварительное выделение *capacity* для `positiveNumbers` равной длине входного слайса (`len(numbers)`).  Это уменьшает количество переаллокаций при `append` (как в задаче 10).  Возвращает новый слайс.

*   **`filterPositiveCopyEfficient2`:**  Предварительно *подсчитывает* количество положительных чисел, затем *точно* выделяет слайс `positiveNumbers` нужной длины (`positiveCount`).  Заполняет слайс значениями.  Это *избегает* даже начального избыточного выделения capacity и переаллокаций.  Но требует *двух проходов* по данным: один для подсчета, второй для заполнения.

*   **Преимущества (Вариант 2):**
    *   **Не изменяет исходный слайс:**  Создает *новый* слайс с результатами, исходный слайс остается нетронутым.
    *   **Эффективнее, чем исходный `filterPositive`:**  `filterPositiveCopyEfficient` минимизирует переаллокации через capacity pre-allocation.  `filterPositiveCopyEfficient2` выделяет память ровно под результат, избегая переаллокаций и потенциально избыточной capacity.
*   **Недостатки (Вариант 2):**
    *   **Выделяет новую память:**  По-прежнему выделяет память для нового слайса.  Менее эффективно по памяти, чем in-place фильтрация.
    *   `filterPositiveCopyEfficient2` требует *двух проходов* (по сравнению с одним проходом для in-place и `filterPositiveCopyEfficient`), что может быть менее эффективно по времени, особенно для очень больших слайсов, где стоимость второго прохода может превысить выгоду от точного выделения памяти.

**Какой вариант предпочесть?**

*   **In-place filtering (`filterPositiveInPlace`)** -  Предпочтителен, когда:
    *   Нужно *максимально экономить память*, особенно при работе с очень большими слайсами.
    *   Допустимо *изменение исходного слайса*.
    *   Порядок элементов (в пределах отфильтрованных элементов) не критичен или может быть сохранен соответствующим образом.
*   **Efficient Copying (`filterPositiveCopyEfficient` or `filterPositiveCopyEfficient2`)** - Предпочтителен, когда:
    *   Нужно *сохранить исходный слайс* без изменений.
    *   Производительность важна, но выделение новой памяти и копирование допустимы.
    *   `filterPositiveCopyEfficient` - хороший компромисс, особенно если нет точной уверенности в размере результата, но известно, что он не превысит размер входных данных.
    *   `filterPositiveCopyEfficient2` - может быть оптимален, если точно известно, что количество отфильтрованных элементов может быть значительно меньше, чем входных, и если стоимость второго прохода не является критичной.

Выбор между вариантами зависит от конкретных требований к задаче: нужно ли сохранять исходные данные, критичны ли память и производительность, и насколько велик ожидаемый объем данных.

</details>

